# Internals: Multi-Session Implementation

This document describes the internal implementation details for developers maintaining the slack-bridge.

For user documentation, see [README.md](README.md).

## Architecture Overview

```
┌─────────┐     ┌───────────────────────────────────────────────┐
│  Slack  │────▶│  tmux session: claude                         │
└─────────┘     │  ┌───────────┐ ┌─────────┐ ┌─────────┐       │
     ▲          │  │  window0  │ │ window1 │ │ window2 │ ...   │
     │          │  │ bridge.js │ │ ae96e6b5│ │ f3b2c891│       │
     │          │  └───────────┘ └─────────┘ └─────────┘       │
     │          └───────────────────────────────────────────────┘
     │                │                       │
     │                ▼                       │
     │          ┌──────────┐                  │
     │          │ sessions │                  │
     │          │  .json   │                  │
     │          └──────────┘                  │
     │                                        │
     └──────────────── slack-notify.sh ◀──────┘
                         (hooks)
```

**tmux window layout:**
- Window 0: `bridge` - runs bridge.js (logs visible here)
- Window 1+: Claude sessions named by session_id (e.g., `ae96e6b5`)

## Core Concepts

### Session Lifecycle

1. **Creation**: New message in main Slack conversation → new Claude session in new tmux window
2. **Active**: Messages in thread → routed to corresponding tmux window
3. **Idle**: Claude calls `idle_prompt` hook → idle timer starts
4. **Timeout**: No activity for configured duration → session terminated
5. **Resurrection**: New message in timed-out thread → resume previous session via `--resume`

### Session Identification

- **Thread ID**: Slack `thread_ts` - unique identifier for the conversation
- **Window Name**: Claude's `session_id` (first 8 chars, e.g., `ae96e6b5`)
  - Window starts with temporary name `new-{index}` during startup
  - Renamed to session_id when Claude sends first response (Stop hook)
- **Claude Session**: Auto-generated by Claude, reported via hooks

**tmux status bar example:**
```
[claude] 0:bridge  1:ae96e6b5  2:f3b2c891  3:new-3*
         ^logs     ^active     ^idle       ^starting
```

## Configuration

### config.json additions

```json
{
  "botToken": "xoxb-...",
  "appToken": "xapp-...",
  "notifyChannel": "D01234567",
  "allowedUsers": ["U01234567"],
  "multiSession": {
    "maxConcurrent": 5,
    "idleTimeoutMinutes": 15,
    "tmuxSession": "claude",
    "defaultWorkingDir": "~"
  }
}
```

### Working Directory

Sessions can specify a working directory using bracket prefix syntax:

```
[~/projects/myapp] Help me fix the login bug
[/home/user/code] What does this codebase do?
```

If no path specified, uses `defaultWorkingDir` from config (default: `~`).

## Session Tracking

### sessions.json

Location: `/tmp/claude-slack-sessions.json`

```json
{
  "1768793377.516429": {
    "window": "ae96e6b5",
    "sessionId": "ae96e6b5-1234-5678-abcd-ef1234567890",
    "channel": "D0A9ZMYRUE4",
    "workingDir": "/home/user/projects/myapp",
    "created_at": "2026-01-19T10:00:00.000Z",
    "last_activity": "2026-01-19T10:15:00.000Z",
    "idle_since": "2026-01-19T10:14:30.000Z",
    "status": "idle"
  },
  "1768793500.123456": {
    "window": "new-1",
    "sessionId": null,
    "channel": "D0A9ZMYRUE4",
    "workingDir": "/home/user",
    "created_at": "2026-01-19T10:05:00.000Z",
    "last_activity": "2026-01-19T10:10:00.000Z",
    "idle_since": null,
    "status": "starting"
  }
}
```

**Note:** `sessionId` is the full UUID for `claude --resume`. `window` is the 8-char prefix used for tmux window naming.

### Status Values

- `starting` - Window created, Claude launching
- `active` - Claude processing (no idle hook received)
- `idle` - Claude waiting for input (idle hook received, timer running)
- `terminated` - Session ended (cleanup pending)

## Implementation Details

### bridge.js Changes

#### Session Creation Lock

Prevent race conditions when multiple messages arrive simultaneously for a new thread:

```javascript
// In-memory lock to prevent duplicate session creation
const creatingSession = new Map();  // threadTs → Promise

async function withSessionLock(threadTs, createFn) {
  // If already creating, wait for it
  if (creatingSession.has(threadTs)) {
    await creatingSession.get(threadTs);
    return null;  // Signal that session was created by another call
  }

  // Create a promise that resolves when we're done
  let resolve;
  const promise = new Promise(r => resolve = r);
  creatingSession.set(threadTs, promise);

  try {
    return await createFn();
  } finally {
    creatingSession.delete(threadTs);
    resolve();
  }
}
```

#### Working Directory Parsing

Parse optional bracket prefix for working directory:

```javascript
import { statSync, readFileSync } from 'fs';
import { execSync } from 'child_process';

// Parse [/path/to/dir] prefix from message
function parseWorkingDir(text) {
  const match = text.match(/^\[([^\]]+)\]\s*/);
  if (match) {
    return {
      requestedPath: match[1],
      message: text.slice(match[0].length)
    };
  }
  return { requestedPath: null, message: text };
}

// Validate and resolve working directory
function resolveWorkingDir(requestedPath) {
  const defaultDir = config.multiSession?.defaultWorkingDir?.replace(/^~/, process.env.HOME) || process.env.HOME;

  if (!requestedPath) {
    return { path: defaultDir, warning: null };
  }

  const resolved = requestedPath.replace(/^~/, process.env.HOME);

  try {
    const stat = statSync(resolved);
    if (!stat.isDirectory()) {
      return { path: defaultDir, warning: `⚠️ Path is not a directory: \`${requestedPath}\`, using default` };
    }
    return { path: resolved, warning: null };
  } catch (e) {
    return { path: defaultDir, warning: `⚠️ Path not found: \`${requestedPath}\`, using default` };
  }
}
```

#### File Locking for sessions.json

Prevent lost updates when bridge.js and hooks write simultaneously:

```javascript
const SESSIONS_FILE = '/tmp/claude-slack-sessions.json';
const SESSIONS_LOCK = '/tmp/claude-slack-sessions.lock';

function loadSessions() {
  try {
    return JSON.parse(readFileSync(SESSIONS_FILE, 'utf-8'));
  } catch {
    return {};
  }
}

function saveSessions(sessions) {
  const json = JSON.stringify(sessions, null, 2);
  // Use flock for atomic write with locking (coordinates with hooks)
  execSync(`flock ${SESSIONS_LOCK} -c 'cat > ${SESSIONS_FILE}'`, { input: json });
}
```

#### Message Handling Flow

```javascript
// Note: 'say' is passed from Bolt event handler and available in closure
async function handleMessage(message, channel, say) {
  const threadTs = message.thread_ts || message.ts;
  const isNewThread = !message.thread_ts;  // First message creates thread

  // Guard against empty messages
  if (!message.text) {
    console.log(`Ignoring empty message in thread ${threadTs}`);
    return;
  }

  // Parse working directory from message (only for new threads)
  let messageText = message.text;
  let workingDir = null;
  let dirWarning = null;

  if (isNewThread) {
    const { requestedPath, message: cleanMessage } = parseWorkingDir(message.text);
    messageText = cleanMessage;
    const resolved = resolveWorkingDir(requestedPath);
    workingDir = resolved.path;
    dirWarning = resolved.warning;
  }

  // Load sessions
  let sessions = loadSessions();

  // Check if session exists for this thread
  let session = sessions[threadTs];

  if (!session || session.status === 'terminated') {
    // Use lock to prevent race condition on simultaneous messages
    const created = await withSessionLock(threadTs, async () => {
      // Re-load sessions inside lock (another call may have created it)
      sessions = loadSessions();
      session = sessions[threadTs];

      // Double-check: session may have been created while we waited for lock
      if (session && session.status !== 'terminated') {
        return null;  // Already exists, skip creation
      }

      // Check concurrent session limit
      const activeCount = Object.values(sessions)
        .filter(s => s.status !== 'terminated').length;

      if (activeCount >= config.multiSession.maxConcurrent) {
        await say({ text: `⚠️ Maximum concurrent sessions (${config.multiSession.maxConcurrent}) reached. Please wait for an existing conversation to complete.`, thread_ts: threadTs });
        return 'limit_reached';
      }

      if (session?.status === 'terminated' && session.sessionId) {
        // Resurrect session using claude --resume (only if we have full session UUID)
        session = await resurrectSession(threadTs, channel, session.sessionId, workingDir);
      } else {
        // Create new session (also for terminated sessions that never got a response)
        session = await createSession(threadTs, channel, workingDir);
      }

      sessions[threadTs] = session;
      saveSessions(sessions);
      return session;
    });

    // Handle lock results
    if (created === 'limit_reached') return;
    if (created === null) {
      // Session was created by concurrent call, reload
      sessions = loadSessions();
      session = sessions[threadTs];
    }

    // Post warning if working directory was invalid
    if (dirWarning) {
      await say({ text: dirWarning, thread_ts: threadTs });
    }
  }

  // Update activity timestamp
  session.last_activity = new Date().toISOString();
  session.idle_since = null;
  session.status = 'active';
  saveSessions(sessions);

  // Send message to appropriate tmux window (use cleaned message without path prefix)
  sendToWindow(session.window, messageText);

  // Add eyes reaction
  await addReaction(channel, message.ts, 'eyes');
}
```

#### Session Creation

```javascript
// Track window index for temporary names (start at 1 since window 0 is bridge)
let windowIndex = 1;

async function createSession(threadTs, channel, workingDir) {
  const tmuxSession = config.multiSession.tmuxSession;

  // Use temporary window name until Claude reports its session_id
  const tempWindowName = `new-${windowIndex++}`;

  // Create new tmux window
  execSync(`tmux new-window -t ${tmuxSession} -n ${tempWindowName}`);

  // Change to working directory first (use double quotes for paths with spaces)
  if (workingDir) {
    execSync(`tmux send-keys -t ${tmuxSession}:${tempWindowName} 'cd "${workingDir}"' Enter`);
  }

  // Start Claude in the window with environment variables (for tool isolation, e.g., browser profiles)
  // Note: Hooks use session_id lookup in sessions.json, not env vars
  const env = `CLAUDE_THREAD_TS=${threadTs} CLAUDE_SLACK_CHANNEL=${channel}`;
  execSync(`tmux send-keys -t ${tmuxSession}:${tempWindowName} '${env} claude' Enter`);

  return {
    window: tempWindowName,  // Will be updated to 8-char session_id by hook
    sessionId: null,         // Will be set to full UUID by hook on first response
    channel: channel,
    workingDir: workingDir || process.env.HOME,
    created_at: new Date().toISOString(),
    last_activity: new Date().toISOString(),
    idle_since: null,
    status: 'starting'
  };
}
```

#### Session Resurrection

When a terminated session receives a new message, resume it using Claude's built-in `--resume` flag:

```javascript
async function resurrectSession(threadTs, channel, fullSessionId, workingDir) {
  const tmuxSession = config.multiSession.tmuxSession;
  const tempWindowName = `new-${windowIndex++}`;

  // Create new tmux window
  execSync(`tmux new-window -t ${tmuxSession} -n ${tempWindowName}`);

  // Change to working directory (use provided or fall back to stored/default)
  // For resurrection, we typically want the same dir as original session
  const sessions = loadSessions();
  const effectiveDir = workingDir || sessions[threadTs]?.workingDir || process.env.HOME;
  execSync(`tmux send-keys -t ${tmuxSession}:${tempWindowName} 'cd "${effectiveDir}"' Enter`);

  // Resume previous Claude session using full UUID (context restored automatically)
  // Env vars for tool isolation; hooks use session_id lookup
  const env = `CLAUDE_THREAD_TS=${threadTs} CLAUDE_SLACK_CHANNEL=${channel}`;
  execSync(`tmux send-keys -t ${tmuxSession}:${tempWindowName} '${env} claude --resume ${fullSessionId}' Enter`);

  return {
    window: tempWindowName,  // Will be renamed to 8-char session_id by hook
    sessionId: fullSessionId, // Keep the same full UUID
    channel: channel,
    workingDir: effectiveDir,
    created_at: new Date().toISOString(),
    last_activity: new Date().toISOString(),
    idle_since: null,
    status: 'starting'
  };
}
```

Note: The session_id remains the same after resurrection since we're resuming the same Claude session.

#### Idle Timeout Cleanup

```javascript
function startCleanupInterval() {
  setInterval(() => {
    const sessions = loadSessions();
    const now = new Date();
    const timeoutMs = config.multiSession.idleTimeoutMinutes * 60 * 1000;

    for (const [threadTs, session] of Object.entries(sessions)) {
      if (session.status === 'idle' && session.idle_since) {
        const idleTime = now - new Date(session.idle_since);

        if (idleTime > timeoutMs) {
          terminateSession(threadTs, session);
        }
      }
    }
  }, 60000); // Check every minute
}

function terminateSession(threadTs, session) {
  const tmuxSession = config.multiSession.tmuxSession;

  // Kill the tmux window
  try {
    execSync(`tmux kill-window -t ${tmuxSession}:${session.window}`);
  } catch (e) {
    // Window may already be gone
  }

  // Update session status
  const sessions = loadSessions();
  sessions[threadTs].status = 'terminated';
  saveSessions(sessions);

  // Notify in Slack thread
  notifySessionEnded(session.channel, threadTs);
}
```

#### Bridge Startup Reconnection

On bridge startup, reconcile sessions.json with actual tmux state:

```javascript
async function reconnectSessions() {
  const sessions = loadSessions();
  const tmuxSession = config.multiSession.tmuxSession;
  let changed = false;

  for (const [threadTs, session] of Object.entries(sessions)) {
    if (session.status === 'terminated') continue;

    // Check if tmux window still exists (select-window fails if window doesn't exist)
    try {
      execSync(`tmux select-window -t ${tmuxSession}:${session.window}`, { stdio: 'ignore' });
      console.log(`✓ Session ${session.window} still active`);
    } catch {
      // Window gone - mark as terminated (can be resurrected via --resume)
      console.log(`✗ Session ${session.window} no longer exists, marking terminated`);
      sessions[threadTs].status = 'terminated';
      changed = true;
    }
  }

  if (changed) {
    saveSessions(sessions);
  }
}

// Call on startup before app.start()
await reconnectSessions();
startCleanupInterval();
```

#### Helper Functions

```javascript
// Send text to a tmux window
function sendToWindow(windowName, text) {
  const tmuxSession = config.multiSession.tmuxSession;
  const escaped = text.replace(/'/g, "'\\''");
  execSync(`tmux send-keys -t ${tmuxSession}:${windowName} -l '${escaped}'`);
  execSync(`tmux send-keys -t ${tmuxSession}:${windowName} Enter`);
}

// Add emoji reaction to a Slack message
async function addReaction(channel, timestamp, emoji) {
  try {
    await app.client.reactions.add({
      channel: channel,
      name: emoji,
      timestamp: timestamp
    });
  } catch (e) {
    // Ignore reaction errors (may already exist)
  }
}

// Notify user that session has ended
async function notifySessionEnded(channel, threadTs) {
  try {
    await app.client.chat.postMessage({
      channel: channel,
      thread_ts: threadTs,
      text: '⏱️ Session timed out due to inactivity. Send a message to restart.'
    });
  } catch (e) {
    console.error(`Failed to notify session end: ${e.message}`);
  }
}
```

### slack-notify.sh Changes

#### Per-Session Context

The hook identifies which session triggered it by looking up `session_id` in `sessions.json`:

```bash
SESSIONS_FILE="/tmp/claude-slack-sessions.json"
SESSIONS_LOCK="/tmp/claude-slack-sessions.lock"

# Get session_id from hook input
SESSION_ID_FULL=$(echo "$INPUT" | jq -r '.session_id // "unknown"')
SESSION_ID="${SESSION_ID_FULL:0:8}"  # First 8 chars for window name

# Get current window name
CURRENT_WINDOW=$(tmux display-message -p '#{window_name}')

# Lookup thread_ts and channel by session_id (window name) in sessions.json
# Check both SESSION_ID and CURRENT_WINDOW because:
# - Before first response: window is "new-X", SESSION_ID is the new session_id
# - After rename: window is session_id, both should match
if [[ -f "$SESSIONS_FILE" ]]; then
  SESSION_DATA=$(jq -r "to_entries[] | select(.value.window == \"$SESSION_ID\" or .value.window == \"$CURRENT_WINDOW\") | \"\(.key)|\(.value.channel)\"" "$SESSIONS_FILE" | head -1)
  THREAD_TS=$(echo "$SESSION_DATA" | cut -d'|' -f1)
  CHANNEL=$(echo "$SESSION_DATA" | cut -d'|' -f2)
fi

# Fallback for single-session mode or if lookup fails
if [[ -z "$THREAD_TS" ]]; then
  THREAD_TS="${CLAUDE_THREAD_TS:-}"
fi
if [[ -z "$CHANNEL" ]]; then
  CHANNEL="${CLAUDE_SLACK_CHANNEL:-}"
fi
```

#### Window Rename on First Response

When Claude sends its first response (Stop event), rename the window to use session_id:

```bash
SESSIONS_LOCK="/tmp/claude-slack-sessions.lock"
TMUX_SESSION="claude"

# On Stop event, rename window if it still has temporary name
if [[ "$EVENT_TYPE" == "Stop" && "$CURRENT_WINDOW" == new-* ]]; then
  # Rename tmux window to session_id (must happen BEFORE sessions.json lookup changes)
  tmux rename-window -t "$TMUX_SESSION:$CURRENT_WINDOW" "$SESSION_ID"

  # Update sessions.json with new window name and full session ID (with file locking)
  if [[ -n "$THREAD_TS" && -f "$SESSIONS_FILE" ]]; then
    flock "$SESSIONS_LOCK" -c "
      TMP_FILE=\$(mktemp)
      jq --arg ts \"$THREAD_TS\" --arg sid \"$SESSION_ID\" --arg sidfull \"$SESSION_ID_FULL\" \
        '.[\$ts].window = \$sid | .[\$ts].sessionId = \$sidfull | .[\$ts].status = \"active\"' \
        \"$SESSIONS_FILE\" > \"\$TMP_FILE\" && mv \"\$TMP_FILE\" \"$SESSIONS_FILE\"
    "
  fi
fi
```

#### Idle Hook Updates Session Status

Within the existing `case "$EVENT_TYPE"` structure, under the `"Notification"` case:

```bash
case "$EVENT_TYPE" in
  "Notification")
    NOTIFICATION_TYPE=$(echo "$INPUT" | jq -r '.notification_type // .matcher // "unknown"')
    case "$NOTIFICATION_TYPE" in
      "idle_prompt")
        # Update session status to idle (with file locking)
        if [[ -n "$THREAD_TS" && -f "$SESSIONS_FILE" ]]; then
          IDLE_TIME=$(date -Iseconds)
          flock "$SESSIONS_LOCK" -c "
            TMP_FILE=\$(mktemp)
            jq --arg ts \"$THREAD_TS\" --arg idle \"$IDLE_TIME\" \
              '.[\$ts].status = \"idle\" | .[\$ts].idle_since = \$idle' \
              \"$SESSIONS_FILE\" > \"\$TMP_FILE\" && mv \"\$TMP_FILE\" \"$SESSIONS_FILE\"
          "
        fi
        exit 0  # Don't send idle notification to Slack
        ;;
      # ... other notification types ...
    esac
    ;;
  # ... other event types ...
esac
```

### Tool Isolation

#### Browser Tool

Modify `~/.claude/browser-tool/browser.js` to use per-session profile:

```javascript
// Use CLAUDE_THREAD_TS for browser profile isolation
const THREAD_TS = process.env.CLAUDE_THREAD_TS || 'default';
const USER_DATA_DIR = `/tmp/claude-browser-${THREAD_TS.replace('.', '-')}`;
```

#### Per-Session Context

The global `/tmp/claude-slack-thread-context.json` is **no longer used** in multi-session mode.

Thread context is now determined by:
1. `CLAUDE_THREAD_TS` and `CLAUDE_SLACK_CHANNEL` environment variables (set when session starts)
2. Lookup in `sessions.json` using current tmux window name
3. Hooks use `session_id` from hook input to lookup in `sessions.json`

Tools like `slack-read-thread.sh` and `slack-upload.sh` use the same detection methods.

## User Commands

### Slash Commands (Optional)

| Command | Description |
|---------|-------------|
| `/claude-sessions` | List active sessions with status and idle time |
| `/claude-kill <thread>` | Manually terminate a session |
| `/claude-status` | Show current session limits and usage |

## Edge Cases

### Max Sessions Reached

When user sends message and limit is reached:
- Reply in thread: "⚠️ Maximum concurrent sessions (5) reached. Please wait for an existing conversation to complete or end one manually."
- Do not create new session
- Do not forward message to any Claude instance

### Session Crash

If Claude crashes (tmux window disappears unexpectedly):
- Detect via periodic health check or failed send
- Update session status to `terminated`
- Notify in Slack thread: "⚠️ Session ended unexpectedly. Send a message to restart."

### Rapid Messages

If multiple messages arrive before session is fully started:
- Messages are sent to tmux immediately regardless of session status
- Tmux input buffering queues them until Claude shows prompt
- This is consistent with Design Decision #3 (streaming messages)

### Simultaneous Session Creation

If two messages arrive for a thread with no existing session:
- In-memory lock (`creatingSession` Map) ensures only one creates the session
- Second message waits for lock, then re-checks sessions.json
- Prevents duplicate tmux windows for the same thread

## Migration Path

### Phase 1: Basic Multi-Session
- [x] Session tracking in sessions.json
- [x] Create tmux windows per thread
- [x] Route messages to correct window
- [x] Basic idle timeout cleanup

### Phase 2: Tool Isolation
- [x] Per-session browser profiles (via `CLAUDE_THREAD_TS` env var)
- [x] Environment variables for tool isolation
- [x] Auto-confirm trust prompt on session start

### Phase 3: Polish
- [x] Slash commands for session management (/claude-sessions, /claude-status, /claude-kill)
- [x] Session resurrection via `claude --resume`
- [x] Crash detection and notification (30s health check)

## Startup

The bridge runs in tmux window 0. Use the startup command:

```bash
slack-claude-start
```

This will:
- Create tmux session `claude` (or use existing)
- Create/use window 0 named `bridge`
- Start `node bridge.js` with logging
- Handle restart via `slack-claude-start --restart`

To start a Claude session from terminal:

```bash
slack-claude ~/projects/myapp "Help me with this"
```

Or send a DM to the bot in Slack.

## Files

All scripts live in `~/.claude/slack-bridge/` with symlinks for global access:

| File | Purpose | Symlink |
|------|---------|---------|
| `bridge.js` | Session management, message routing | - |
| `config.json` | Multi-session configuration | - |
| `install.sh` | Installation and setup | - |
| `slack-notify.sh` | Hook: notifications, idle status, window renaming | `~/.claude/` |
| `slack-forward-prompt.sh` | Hook: forward user prompts to Slack | `~/.claude/` |
| `slack-read-thread.sh` | Tool: read Slack thread history | `~/.claude/` |
| `slack-upload.sh` | Tool: upload files to Slack | `~/.claude/` |
| `slack-claude.sh` | Start Claude session from terminal | `~/.local/bin/slack-claude` |
| `slack-claude-start.sh` | Start bridge infrastructure | `~/.local/bin/slack-claude-start` |
| `slack-bridge.md` | Global Claude Code rules | `~/.claude/rules/` |

Related (separate project):
- `~/.claude/browser-tool/browser.js` - Per-session browser profiles (uses `CLAUDE_THREAD_TS`)

## Design Decisions

1. **Terminated session cleanup**: **No** - keep thread → session_id mappings indefinitely to enable resurrection via `claude --resume`
2. **Persist across restarts**: Yes - sessions.json survives bridge restarts; reconnect to existing tmux windows on startup
3. **Messages during streaming**: Tmux input buffering handles this acceptably - messages queue in tmux and submit when Claude shows prompt
4. **Timeout configuration**: Global only - no per-conversation timeout needed
5. **Session resurrection**: Use `claude --resume <full-uuid>` to restore full conversation context (requires full UUID, not 8-char truncated version)
6. **Race condition prevention**: In-memory lock (`creatingSession` Map) prevents duplicate sessions when multiple messages arrive simultaneously for the same thread
7. **Hook session identification**: Hooks lookup `thread_ts` and `channel` from `sessions.json` using `session_id` (reverse lookup) - no environment variable propagation needed
8. **File locking**: Use `flock` on `/tmp/claude-slack-sessions.lock` for all writes to `sessions.json` - prevents lost updates when bridge.js and hooks write simultaneously
9. **Working directory**: Bracket prefix syntax `[/path/to/dir]` at start of message; defaults to `~`; invalid paths fall back to default with warning in thread
10. **Window 0 purpose**: Run bridge.js in window 0 (`bridge`) for easy log monitoring; Claude sessions use windows 1+
11. **Backward compatibility**: None - multi-session replaces single-session entirely (no `enabled` toggle)
